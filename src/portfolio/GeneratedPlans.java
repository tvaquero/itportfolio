package portfolio;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.io.*;
import java.util.Vector;
import org.jaxen.JaxenException;
import org.jaxen.XPath;
import org.jaxen.jdom.JDOMXPath;
import org.jdom.*;

import languages.xml.*;

public class GeneratedPlans {

	//This class is used for storing the plans generated by the planners
	private List<List<Element>> Plans;
	//Plans is structed in 2 level. The outer list represents the planners, the inner the training instances
	//e.g. Plans.at(1).at(2) indicates the plan generated by the 2nd planner for the 3rd problem.
	
	//The following 2 lists are used for storing, for each training problem, the best solution and/or 
	//the minimum CPU time accross al the considered planners.
	private List<Float> Best_quality;
	private List<Float> Best_CPU_time;
	
	String allocation; // the allocation strategy
	String selection; //the selection strategy
	String target; //the target to optimize
	
	public String getTarget() {
		return target;
	}

	public void setTarget(String target) {
		this.target = target;
	}

	public GeneratedPlans(){
		Plans = new ArrayList<List<Element>>();
		Best_quality = new ArrayList<Float>();
		Best_CPU_time = new ArrayList<Float>();	
	}
	
	public String getAllocation() {
		return allocation;
	}

	public void setAllocation(String allocation) {
		this.allocation = allocation;
	}

	public String getSelection() {
		return selection;
	}

	public void setSelection(String selection) {
		this.selection = selection;
	}
	
	
	public void save_plan(int planner, int problem, Element xmlPlan){
		if(Plans.size() <= planner)
			Plans.add(new ArrayList<Element>());
		List<Element> single= Plans.get(planner);
		single.add(xmlPlan);
		Plans.set(planner, single);
		return;
	}
	
	public Element get_plan(int planner, int problem){
		return Plans.get(planner).get(problem);
	}
	
	public void print_all_plans(){
		for(int i=0; i < Plans.size(); i++)
			for(int j=0; j < Plans.get(i).size(); j++){
				XMLUtilities.printXML(Plans.get(i).get(j));
			}
	}
	
	public ConfiguredPortfolio portfolio_configuration(int min, int max, float timeout){
		ConfiguredPortfolio to_configure = new ConfiguredPortfolio(max);
//		for(int i=0; i< consideredplannerslist.size()-1; i++){
		//			for(int j=0; j < training_instances.size(); j++ ){
		//				Element test = plans.get_plan(i, j);
		//				System.out.println(test.getChild("statistics").getChildText("time"));
		//			}
		//		}
		String technique=allocation+selection+target;
		System.out.println(technique);
		if(technique.equals("sametimeIPC-scorequality")){
			to_configure = IPC_same_q(min,max,timeout);
		}else{
			System.out.println("Allocation and/or Selection strategy not supported (yet..)");
		}
		return to_configure;
	}
	
	private ConfiguredPortfolio IPC_same_q(int min, int max, float timeout){
//		ConfiguredPortfolio to_configure = new ConfiguredPortfolio(max);
		Vector<ConfiguredPortfolio> portfolios; 
		int position_selected=-1;
		portfolios = GeneratePortfolios(min,max);
		for(int i=0; i < portfolios.size(); i++){
			//THIS IS THE CYCLE FOR ALLOTTING TIME TO THE PLANNERS IN THE PORTFOLIOS
			Vector<Vector<Float>> CPU_t = new Vector<Vector<Float>> ();
			portfolios.elementAt(i).toString();
			int size=portfolios.elementAt(i).numberPlanners();
			float allotted=timeout/size;
			for(int h=0; h < size; h++){
				CPU_t.add(new Vector<Float> ());
				CPU_t.elementAt(h).add(allotted);
			}
			portfolios.elementAt(i).setCPU_time(CPU_t);
		}
		calculateBestQuality();
		for (int j=0; j < portfolios.size(); j++){
			// QUA DEVO METTERE POI LA SIMULAZIONE PORTFOLIO PER PORTFOLIO
			SimulateSequentialExecution(portfolios.elementAt(j));
		}
		
		double max_quality=0;
		for(int i=0; i < portfolios.size(); i++ ){
			if(portfolios.elementAt(i).getScore() > max_quality){
				max_quality=portfolios.elementAt(i).getScore();
				position_selected=i;
			}
		}
		
		return portfolios.elementAt(position_selected);
	}
	
	private void SimulateSequentialExecution(ConfiguredPortfolio to_simulate){
		//read CPU time of the planners, read quality of the planners, 
		//simulate the execution of the portfolio, update the score.
		return;
	}
	
	private void calculateBestQuality(){//fills the best_quality list
		print_all_plans();
		float min;
		for(int i=0; i < Plans.get(0).size(); i++ ){
			min=java.lang.Float.MAX_VALUE;
			for(int j=0; j < Plans.size(); j++ ){
				//if(Plans.get(j).get(i).getChildText("message").equals("Planner generated a solution."))
				//We have to cycle on the problems for finding the best possible solution. 
				//System.out.println( Plans.get(j).get(i).getChild("toolInformation").getChildText("message") );
			}
		}
		return;
	}
	
	private void calculateBestCPU(){ //fills the best_CPU list
		return;
	}
	
	private Vector<ConfiguredPortfolio> GeneratePortfolios(int min, int max){
		Vector<ConfiguredPortfolio> to_return = new Vector<ConfiguredPortfolio> ();
		int number_of_planners = Plans.size();
		if(max > number_of_planners)
			max=number_of_planners;
		Vector<Vector<String>> prova = MathHelp.Permutations(number_of_planners, max);
		for(int j=min-1; j < prova.size(); j++){
			for(int h=0; h< prova.elementAt(j).size(); h++){
				ConfiguredPortfolio insert = new ConfiguredPortfolio(max);
				//System.out.println("J: "+j+" H: "+h+" "+prova.elementAt(j).elementAt(h));
				//CONFIGURE THE PORTFOLIO
				String[] varie = prova.elementAt(j).elementAt(h).split(",");
				for(int w=0; w < varie.length; w++)
					insert.addPlanner(Integer.parseInt(varie[w]));
				to_return.add(insert);
			}
		}
		return to_return;
	}
	

	
	
}
